<html>
<head>
    <meta charset="UTF-8">
    <title>Instructions</title>
    <link rel="stylesheet" type="text/css" media="all" href="styles.css" />
    <link href="https://fonts.googleapis.com/css?family=Unica+One|Noticia+Text:400,400i,700,700i|Fira+Mono:400,700,&amp;subset=latin-ext" rel="stylesheet">
    <link rel="stylesheet" href="highlight/styles/github.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="highlight/highlight.pack.js"></script>
    <script>
        $(document).ready(function()
        {
          $('code.x86asm').each(function(i, block)
          {
            hljs.highlightBlock(block);
          });
          $('code.swift').each(function(i, block)
          {
            hljs.highlightBlock(block);
          });
          $('pre.x86asm').each(function(i, block)
          {
            hljs.highlightBlock(block);
          });
        });
    </script>
</head>
<body>
    <a class="nav-triangle-left" href="chapter2.html"><div>Prev</div></a>
    <a class="nav-triangle-right" href="chapter4.html"><div>Next</div></a>

    <div class="content-container">
        <div class="content">
            <div class="chapter-header"><div class="chapter-number">3</div><h1>Instructions</h1></div><p><strong>Instructions</strong> specify actions that the computer can perform. To a computer, data values are like nouns. Instructions are like verbs.</p><p>Instructions consist of an operation, and multiple operands. The word “instruction” can also refer to just the operation itself. Operands specify the input data for the operation. An operand can be an <keyword>immediate</keyword> (a constant, hardcoded) value, or the address of a memory location containing the value. <keyword>Registers</keyword>, special high-speed data storage units, are also valid operands. Although the theoretical <keyword>random access machine</keyword> model does not involve registers, only memory, real computers have a set of registers, collectively called the <keyword>register file</keyword>, which serve as scratch space for computations.</p><h2>Registers store high-traffic data</h2><p>Registers are about 3-12 times faster to access than the fastest parts of memory making them ideal for storing frequently used data. They’re also usually several times the size of a single byte allowing them to store multi-byte values. A typical CPU has eight to perhaps thirty registers, though some specialized chips, like GPUs, can have hundreds.</p><aside>We can assume the first four names were chosen so that they would spell out the first four letters of the alphabet when abbreviated. Don’t ask what the <code>r</code> stands for, or the <code>x</code> for that matter. It’s a certified mess.</aside><p>Unlike memory locations, registers do not have addresses. Instructions refer to them by name. In the <keyword>x86_64 architecture</keyword>, the first eight <keyword>general-purpose registers</keyword> are named <code class="x86asm">rax</code>, <code class="x86asm">rcx</code>, <code class="x86asm">rdx</code>, <code class="x86asm">rbx</code>, <code class="x86asm">rsp</code>, <code class="x86asm">rbp</code>, <code class="x86asm">rsi</code>, and <code class="x86asm">rdi</code>, which stand for “<em>accumulator</em>”, “<em>counter</em>”, “<em>data</em>”, “<em>base</em>”, “<em>stack pointer</em>”, “<em>base pointer</em>”, “<em>source</em>”, and “<em>destination</em>”. The names came from what the designers of x86_64 first assumed people would mainly use them for, though today, most people use them interchangably. The next eight registers are just numbered <code class="x86asm">r8</code> through <code class="x86asm">r15</code>.</p><h2>Architectures define instruction sets</h2><p>Architectures define <keyword>instruction sets</keyword>, which are the sets of operations processors can do. The x86_64 architecture and its parent, x86, are some of the most common in the world. They are by no means the only ones. ARM, an alternative class of architectures, is common in mobile devices. Your phone’s processor is probably ARM. Your desktop’s is probably x86_64. This book will use x86_64 for its examples, though the specific architecture used is unimportant.</p><p>Instruction sets usually come with <keyword>mnemonics</keyword>, short human-readable names that stand for types of processor operations. Examples of x86_64 mnemonics include <code class="x86asm">mov</code> (the “move” instruction) and <code class="x86asm">add</code> (the “add” instruction). Instructions written in mnemonics are called <keyword>assembly</keyword>.</p><h2>x86 assembly basics</h2><aside>Here we use the <keyword>GNU assembly</keyword>, or <keyword>GAS</keyword> x86 syntax. Another x86 syntax called <keyword>Intel syntax</keyword> also exists, which we won’t use.</aside><p>Instructions in x86 assembly take the form:</p><pre>operation operand1, operand2</pre><p>Some instructions only take one operand and so are just written:</p><pre>operation operand</pre><p>Register operands are written with the name of the register, prefixed with a percent sign (<code class="x86asm">%rax</code>). For most instructions, all the general-purpose registers are valid operands, though a few require a specific register like <code class="x86asm">%rcx</code> to be used.</p><p>Memory operands are written in <keyword>addressing modes</keyword>, a system for computing addresses given up to four parameters. The syntax for an addressing mode is</p><pre>displacement(base, index, stride)</pre><p>which yields the address <simple-math><var>displacement</var> + <var>base</var> + <var>index</var> × <var>stride</var></simple-math>. The base and index parameters are registers, while the displacement and stride parameters are constant values. Only strides of 1, 2, 4, and 8 are allowed. For example, <code class="x86asm">4(%rbx, %rcx, 8)</code> evaluates to the memory address <simple-math>4 + <var>rbx</var> + 8<var>rcx</var></simple-math>.</p><p>All four addressing mode parameters are optional. By default, the displacement, base, and index parameters are 0, while the stride parameter is 1. <code class="x86asm">4(%rbx, %rcx)</code>, <code class="x86asm">4(%rbx)</code>, <code class="x86asm">4(, %rcx, 8)</code>, and <code class="x86asm">(%rbx)</code> are all valid addressing modes. Literal numbers by themselves, like <code class="x86asm">4</code>, are also valid addressing modes; in this case, <code class="x86asm">4</code> refers to memory location 4.</p><p>Immediate (literal) operands are written with a dollar sign prefix (<code class="x86asm">$15</code>). Forgetting to prefix immediate values with the <code>$</code> is a common beginner mistake. <code class="x86asm">$15</code> is the constant number 15, while <code class="x86asm">15</code> is the value <em>stored in memory location</em> 15. Not all instructions accept immediate operands; some of the less-common ones require you to first load the value into a register and then specify the register as the operand.</p><p>Instructions that take two operands can take a maximum of one immediate operand and one memory operand, so <code class="x86asm">addq $22, $22</code>, and <code class="x86asm">addq (%eax), (%eax)</code> are not valid x86 instructions. An operation on two immediate values always evaluates to a constant, so there’s no point in allowing an instruction to take two immediate operands. The memory operand restriction is a limitation of the x86 architecture. In theory you could design a processor that could operate on two memory locations at a time, though it probably wouldn’t be very efficient.</p><p>Modern x86_64 has well over 900 instructions, though only a dozen or so are used commonly. Each instruction comes in one or more flavors which indicate the size of the data they operate on. The size is written as a suffix, <code>b</code> (“byte”, 1 byte), <code>w</code> (“word”, 2 bytes), <code>l</code> (“long”, 4 bytes), or <code>q</code> (“quadword”, 8 bytes), at the end of the mnemonic. For example, <code class="x86asm">movq</code> is the move instruction for 8-byte values.</p><aside>Memorizing x86 instructions is not important. All that is relevant is knowing they exist and knowing the kinds of things they can do.</aside><p>Some of the most commonly used x86_64 instructions are listed below for reference. Only the quadword flavor of each instruction is shown.</p><h2>Data movement instructions</h2><pre class="x86-prototype"><keyword>movq</keyword> source, destination</pre><p>Moves the value in <code>source</code> into <code>destination</code>.</p><p><em>Example:</em> <code class="x86asm">movq %rax, (%rdi)</code></p><pre class="x86-prototype"><keyword>pushq</keyword> source</pre><p>Decrements <code>rsp</code> by 8 (for a quadword) and then stores <code>source</code> in the memory location referenced by <code>rsp</code>. This instruction is useful when using <code>rsp</code> as a pointer to the top of a stack.</p><p><em>Example:</em> <code class="x86asm">pushq %rax</code></p><pre class="x86-prototype"><keyword>popq</keyword> destination</pre><p>Loads the value from the memory location referenced by <code>rsp</code> into <code>destination</code> and then increments <code>rsp</code> by 8 (for a quadword). This instruction is the opposite of <code class="x86asm">pushq</code>.</p><p><em>Example:</em> <code class="x86asm">popq %rax</code></p><h2>Arithmetic instructions</h2><pre class="x86-prototype"><keyword>addq</keyword> addend, destination</pre><p>Adds the value in <code>addend</code> to the value in <code>destination</code>, and stores the result in <code>destination</code>.</p><p><em>Example:</em> <code class="x86asm">addq $15, (%rdx)</code></p><pre class="x86-prototype"><keyword>subq</keyword> subtrahend, destination</pre><p>Subtracts the value in <code>subtrahend</code> from the value in <code>destination</code>, and stores the result in <code>destination</code>.</p><p><em>Example:</em> <code class="x86asm">subq $10, %rax</code></p><pre class="x86-prototype"><keyword>mulq</keyword> factor</pre><p>Multiplies the value in <code>factor</code> with the value in <code>rax</code>, and stores the low 64 bits of the result in <code>rax</code>. The high 64 bits (overflow bits) go into <code>rdx</code>. The multiplication performed is unsigned.</p><p><em>Example:</em> <code class="x86asm">mulq %rcx</code></p><pre class="x86-prototype"><keyword>divq</keyword> divisor</pre><p>Divides the 128-bit value stored jointly by <code>rax</code> (low 64 bits) and <code>rdx</code> (high 64 bits) by the value in <code>divisor</code>, and stores the result in <code>rax</code>. The division performed is unsigned. Note that the result may overflow <code>rax</code>.</p><p><em>Example:</em> <code class="x86asm">divq %rcx</code></p><pre class="x86-prototype"><keyword>negq</keyword> destination</pre><p>Negates the value stored in <code>destination</code>.</p><p><em>Example:</em> <code class="x86asm">negq %rax</code></p><h2>Shift instructions</h2><pre class="x86-prototype"><keyword>shlq</keyword> amount, destination</pre><p>Shifts the value in <code>destination</code> left by <code>amount</code>, which must be either an immediate value or the register <code>cl</code> (the lowest byte of <code>rcx</code>.)</p><p><em>Example:</em> <code class="x86asm">shlq %cl, (%edi)</code></p><pre class="x86-prototype"><keyword>shrq</keyword> amount, destination</pre><p>Logically shifts the value in <code>destination</code> right by <code>amount</code>, which must be either an immediate value or the register <code>cl</code> (the lowest byte of <code>rcx</code>.)</p><p><em>Example:</em> <code class="x86asm">shrq $3, %edx</code></p><pre class="x86-prototype"><keyword>sarq</keyword> amount, destination</pre><p>Arithmetically shifts the value in <code>destination</code> right by <code>amount</code>, which must be either an immediate value or the register <code>cl</code> (the lowest byte of <code>rcx</code>.)</p><p><em>Example:</em> <code class="x86asm">sarq $1, 8(%ebx)</code></p><h2>Logical instructions</h2><pre class="x86-prototype"><keyword>notq</keyword> destination</pre><p>Inverts the bits in <code>destination</code>.</p><p><em>Example:</em> <code class="x86asm">notq %edx</code></p><pre class="x86-prototype"><keyword>andq</keyword> mask, destination</pre><p>Stores the bitwise conjunction of <code>mask</code> and <code>destination</code> in <code>destination</code>.</p><p><em>Example:</em> <code class="x86asm">andq $15, %eax</code></p><pre class="x86-prototype"><keyword>orq</keyword> value, destination</pre><p>Stores the bitwise disjunction of <code>value</code> and <code>destination</code> in <code>destination</code>.</p><p><em>Example:</em> <code class="x86asm">orq %ecx, %eax</code></p><pre class="x86-prototype"><keyword>xorq</keyword> value, destination</pre><p>Stores the bitwise exclusive disjunction of <code>value</code> and <code>destination</code> in <code>destination</code>.</p><p><em>Example:</em> <code class="x86asm">xorq %eax, %eax</code></p><h2>Assembly programs</h2><p>Assembly instructions form the building blocks of <keyword>programs</keyword>. For example, the following instructions executed in sequence compute the absolute value of <code>rcx</code> and store the result in <code>rax</code>.</p><pre class="x86asm">movq    %rcx, %rax<br/>sarq    $63 , %rcx<br/>xorq    %rcx, %rax<br/>subq    %rcx, %rax</pre><p>Let’s review what each of these instructions do.</p><pre class="x86asm">movq    %rcx, %rax</pre><p>The first instruction makes a copy of the value in <code>rcx</code> and places it in <code>rax</code>.</p><pre class="x86asm">sarq    $63 , %rcx</pre><p>An arithmetic right shift takes the sign bit of <code>rcx</code> and copies it into the other 63 bits of the register. Since the sign bit of a binary integer is 0 if positive or 1 if negative, <code>rcx</code> will contain the all-zeroes bit pattern <code>0x0000_0000_0000_0000</code> if positive, or the all-ones bit pattern <code>0xffff_ffff_ffff_ffff</code> if negative.</p><pre class="x86asm">xorq    %rcx, %rax</pre><p>Since a value xor-ed with the all-zeroes bit pattern gives you the original value, and a value xor-ed with the all-ones bit pattern flips all its bits, this instruction takes the ones complement of <code>rax</code> if it’s negative. Recall this is the first step in negating a binary signed integer.</p><pre class="x86asm">subq    %rcx, %rax</pre><p>This instruction subtracts <code>rcx</code> from <code>rax</code>. Remember that in signed integer representation, the all-zeros bit pattern is 0, and the all-ones bitpattern is −1. Since subtracting −1 is the same as adding 1, this instruction adds either 0 or 1 to <code>rax</code> depending on <code>rcx</code>. Recall adding 1 is the second step in negating a binary signed integer. So at the end of this, <code>rax</code> contains the negative of <code>rcx</code> if negative, and <code>rcx</code> itself if positive.</p>
        </div>
    </div>
</body>
</html>