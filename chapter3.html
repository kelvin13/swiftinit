<html>
<head>
    <meta charset="UTF-8">
    <title>Computing</title>
    <link rel="stylesheet" type="text/css" media="all" href="styles.css" />
    <link href="https://fonts.googleapis.com/css?family=Unica+One|Noticia+Text:400,400i,700,700i|Fira+Mono:400,700,&amp;subset=latin-ext" rel="stylesheet">
    <link rel="stylesheet" href="highlight/styles/github.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="highlight/highlight.pack.js"></script>
    <script>
        $(document).ready(function()
        {
          $('code.x86asm').each(function(i, block)
          {
            hljs.highlightBlock(block);
          });
          $('code.swift').each(function(i, block)
          {
            hljs.highlightBlock(block);
          });
          $('pre.x86asm').each(function(i, block)
          {
            hljs.highlightBlock(block);
          });
        });
    </script>
</head>
<body>
    <a class="nav-triangle-left" href="chapter2.html"><div>Prev</div></a>


    <div class="content-container">
        <div class="content">
            <div class="chapter-header"><div class="chapter-number">3</div><h1>Computing</h1></div><p>Memory allows a computer to store data but to make it actually <em>do anything</em>, you have to feed it <keyword>instructions</keyword> to execute.</p><p>Instructions consist of an operation, and multiple operands. The word “instruction” can also refer to just the operation itself. Operands specify the input data for the operation. An operand can be an <keyword>immediate</keyword> (a constant, hardcoded) value, or the address of a memory location containing the value. <keyword>Registers</keyword>, special high-speed data storage units, are also valid operands. Although the theoretical <keyword>random access machine</keyword> model does not involve registers, only memory, real computers have a set of registers, collectively called the <keyword>register file</keyword>, which serve as scratch space for computations.</p><h2>Registers store high-traffic data</h2><p>Accessing registers is about 3-12 times faster than accessing the fastest parts of memory making them ideal for storing frequently used data. Registers are typically several times the size of a single byte allowing them to store multi-byte values. The size of the register file is usually in the high single- to low double-digits for a typical CPU, though some specialized chips, like GPUs, can contain hundreds.</p><aside>We can assume the first four names were chosen so that they would spell out the first four letters of the alphabet when abbreviated.</aside><p>Unlike memory locations, registers do not have addresses. Instructions refer to them by name. In the <keyword>x86_64 architecture</keyword>, the first eight general-purpose registers are named <code class="x86asm">rax</code>, <code class="x86asm">rbx</code>, <code class="x86asm">rcx</code>, <code class="x86asm">rdx</code>, <code class="x86asm">rsi</code>, <code class="x86asm">rdi</code>, <code class="x86asm">rbp</code>, and <code class="x86asm">rsp</code>, which stand for “<em>accumulator</em>”, “<em>base</em>”, “<em>counter</em>”, “<em>data</em>”, “<em>source</em>”, “<em>destination</em>”, “<em>base pointer</em>”, and “<em>stack pointer</em>”, named after what the designers of x86_64 assumed each register would be primarily used for.</p><h2>Architectures define instruction sets</h2><p>Architectures define <keyword>instruction sets</keyword>, which are the sets of operations processors can do. The x86_64 architecture and its parent, x86, are some of the most common in the world. They are by no means the only ones. ARM, an alternative class of architectures, is common in mobile devices. Your phone’s processor is probably ARM. Your desktop’s is probably x86_64. This book will use x86_64 for its examples, though the specific architecture used is unimportant.</p><p>Instructions are encoded in binary <keyword>machine code</keyword> which the processor can execute directly. Since binary machine code is unintelligible to us humans, instructions are usually given <keyword>mnemonics</keyword>, short nicknames that stand in for binary codewords. Examples of x86_64 mnemonics include <code class="x86asm">mov</code> (the “move” instruction) and <code class="x86asm">add</code> (the “add” instruction). Instructions written in mnemonics are called <keyword>assembly</keyword>, and are translated into machine code by an <keyword>assembler</keyword>.</p><h2>x86 assembly basics</h2><aside>Here we use the <keyword>GNU assembly</keyword>, or <keyword>GAS</keyword> x86 syntax. Another x86 syntax called <keyword>Intel syntax</keyword> also exists, which we won’t use.</aside><p>Instructions in x86 assembly take the form:</p><pre>operation operand1, operand2</pre><p>Some instructions only take one operand and so are just written:</p><pre>operation operand.</pre><p>Register operands are written with the name of the register, prefixed with a percent sign (<code class="x86asm">%rax</code>). For most instructions, all the general-purpose registers are valid operands, though a few require a specific register like <code class="x86asm">%rcx</code> to be used.</p><p>Memory operands are written in <keyword>addressing modes</keyword>, a system for computing addresses given up to four parameters. The syntax for an addressing mode is</p><pre>displacement(base, index, stride)</pre><p>which yields the address <simple-math><var>displacement</var> + <var>base</var> + <var>index</var> × <var>stride</var></simple-math>. The base and index parameters are registers, while the displacement and stride parameters are constant values. Only strides of 1, 2, 4, and 8 are allowed. For example, <code class="x86asm">4(%rbx, %rcx, 8)</code> evaluates to the memory address <simple-math>4 + <var>rbx</var> + 8<var>rcx</var></simple-math>.</p><p>All four addressing mode parameters are optional. By default, the displacement, base, and index parameters are 0, while the stride parameter is 1. <code class="x86asm">4(%rbx, %rcx)</code>, <code class="x86asm">4(%rbx)</code>, <code class="x86asm">4(, %rcx, 8)</code>, and <code class="x86asm">(%rbx)</code> are all valid addressing modes. Literal numbers by themselves, like <code class="x86asm">4</code>, are also valid addressing modes; in this case, <code class="x86asm">4</code> refers to memory location 4.</p><p>Immediate (literal) operands are written with a dollar sign prefix (<code class="x86asm">$15</code>). Forgetting to prefix immediate values with the <code>$</code> is a common beginner mistake. <code class="x86asm">$15</code> is the constant number 15, while <code class="x86asm">15</code> is the value <em>stored in memory location</em> 15. Not all instructions accept immediate operands; some of the less-common ones require you to first load the value into a register and then specify the register as the operand.</p><p>Instructions that take two operands can take a maximum of one immediate operand and one memory operand, so <code class="x86asm">addq $22, $22</code>, and <code class="x86asm">addq (%eax), (%eax)</code> are not valid x86 instructions. An operation on two immediate values always evaluates to a constant, so there’s no point in allowing an instruction to take two immediate operands. The memory operand restriction is a limitation of the x86 architecture — in theory you could design a processor that can operate on two memory locations at a time (though it probably wouldn’t be very efficient.)</p><p>Modern x86_64 has well over 900 instructions, though only a dozen or so are used commonly. Each instruction comes in one or more flavors which indicate the size of the data they operate on. The size is written as a suffix, <code>b</code> (“byte”, 1 byte), <code>w</code> (“word”, 2 bytes), <code>l</code> (“long”, 4 bytes), or <code>q</code> (“quadword”, 8 bytes), at the end of the mnemonic. For example, <code class="x86asm">movq</code> is the move instruction for 8-byte values.</p><p>Some of the most commonly used x86_64 instructions are listed below. Only the quadword flavor of each instruction is shown.</p><h2>Data movement instructions</h2><pre class="x86-prototype"><keyword>movq</keyword> source, destination</pre><p>Moves the value in <code>source</code> into <code>destination</code>.</p><p><em>Example:</em> <code class="x86asm">movq %rax, (%rdi)</code></p><pre class="x86-prototype"><keyword>pushq</keyword> source</pre><p>Decrements <code>rsp</code> by 8 (for a quadword) and then stores <code>source</code> in the memory location referenced by <code>rsp</code>. This instruction is useful when using <code>rsp</code> as a pointer to the top of a stack.</p><p><em>Example:</em> <code class="x86asm">pushq %rax</code></p><pre class="x86-prototype"><keyword>popq</keyword> destination</pre><p>Loads the value from the memory location referenced by <code>rsp</code> into <code>destination</code> and then increments <code>rsp</code> by 8 (for a quadword). This instruction is the opposite of <code class="x86asm">pushq</code>.</p><p><em>Example:</em> <code class="x86asm">popq %rax</code></p><h2>Arithmetic and logic instructions</h2><pre class="x86-prototype"><keyword>addq</keyword> source, destination</pre><p>Adds the value in <code>source</code> to the value in <code>destination</code>, and stores the result in <code>destination</code>.</p><p><em>Example:</em> <code class="x86asm">addq $15, (%rdx)</code></p><pre class="x86-prototype"><keyword>subq</keyword> source, destination</pre><p>Subtracts the value in <code>source</code> from the value in <code>destination</code>, and stores the result in <code>destination</code>.</p><p><em>Example:</em> <code class="x86asm">subq $10, %rax</code></p>
        </div>
    </div>
</body>
</html>